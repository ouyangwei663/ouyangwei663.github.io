(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{736:function(t,e,a){},759:function(t,e,a){"use strict";a(736)},767:function(t,e,a){"use strict";a.r(e);a(759);var r=a(52),o=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"vue-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[t._v("#")]),t._v(" Vue 生命周期")]),t._v(" "),a("blockquote",[a("p",[t._v("什么是生命周期呢，vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom、渲染 → 更新 → 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 js 方法，可以让我们用自己注册的 js 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 vue 的实例。")])]),t._v(" "),a("h3",{attrs:{id:"vue2-的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-的生命周期"}},[t._v("#")]),t._v(" vue2 的生命周期")]),t._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[t._v("点击这里查看 vue2 生命周期的流程图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/ouwei663/pictruerecord/raw/master/images/664019-20170427110242647-1540188465.png",alt:"image.png"}})])]),t._v(" "),a("p",[t._v("大概整理一下 "),a("a-timeline",{staticStyle:{"margin-top":"20px"}},[a("a-timeline-item",[a("strong",[t._v("beforeCreate")]),t._v(" "),a("br"),t._v(" beforeCreate 在文件初始化之前，此时无数据（data）,也无 dom ")]),t._v(" "),a("a-timeline-item",{attrs:{color:"green"}},[a("strong",[t._v("Create")]),t._v(" "),a("br"),t._v(" created 表示文件已创建（初始化完成），data 现在和方法都已经存在，但是 dom 还未渲染。所以在此之前不可以操作 dom,除非你使用 nexttick 钩子 ")]),t._v(" "),a("a-timeline-item",[a("strong",[t._v("berforemounted")]),t._v(" "),a("br"),t._v("这里便是 dom 树已经生成完毕，并渲染基础初始数据的 dom,这里可以操作初始 dom ")]),t._v(" "),a("a-timeline-item",{attrs:{color:"red"}},[a("strong",[t._v("mounted")]),t._v(" "),a("br"),t._v(" 这里是第一次数据完成更新后，渲染后的 dom。一般可以在这个位置请求初始需要的数据。当然如果不需要立刻操作 dom 的话在 created 也是可以请求的 ")]),t._v(" "),a("a-timeline-item",[a("a-icon",{staticStyle:{"font-size":"16px"},attrs:{slot:"dot",type:"clock-circle-o"},slot:"dot"}),t._v(" "),a("strong",[t._v("beforeupdate")]),t._v(" "),a("br"),t._v(" 更新前 ")],1),t._v(" "),a("a-timeline-item",[a("a-icon",{staticStyle:{"font-size":"16px"},attrs:{slot:"dot",type:"clock-circle-o"},slot:"dot"}),a("strong",[t._v("update")]),t._v(" "),a("br"),t._v(" 更新后 ")],1),t._v(" "),a("a-timeline-item",[a("strong",[t._v("beforedestory")]),t._v(" "),a("br"),t._v(" 销毁前 ")]),t._v(" "),a("a-timeline-item",[a("strong",[t._v("destory")]),t._v(" "),a("br"),t._v(" 销毁后 ")])],1)],1),t._v(" "),a("h2",{attrs:{id:"computed-和-watch-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-有什么区别"}},[t._v("#")]),t._v(" Computed 和 Watch 有什么区别")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("computed")]),t._v("是计算属性，依赖于data里面的数据。个人理解为多对一的关系，监听多个（一个也行）所依赖的数据，其中一个数据改变，最后通过计算得出数据在return 回去。如果依赖的数据没有改变，那么就从缓存中读取。")])]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("watch")]),t._v("是监听属性，监听data里面的数据。个人理解为一对多（一对一）的关系，通过监听一个数据，当这个数据发生改变时候在进行相对应的操作。watch只会监听数据的值是否发生改变，而不会去监听数据的地址是否发生改变。也就是说，watch想要监听引用类型数据的变化，需要进行深度监听。就是设置deep属性为true")])]),t._v(" "),a("a-alert",{attrs:{message:"这两者其实有共同之处，但是最大的区别在于computed,需要监听多个依赖有缓存且不支持异步，所以当执行开销大或者异步的操作时候选择watch",type:"warning","show-icon":""}}),t._v(" "),a("h2",{attrs:{id:"vue-路由有多少种模式-以及对应模式的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-路由有多少种模式-以及对应模式的实现原理"}},[t._v("#")]),t._v(" Vue 路由有多少种模式，以及对应模式的实现原理")])],1)}),[],!1,null,null,null);e.default=o.exports}}]);